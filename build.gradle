import groovy.json.JsonOutput
import org.gradle.api.attributes.java.TargetJvmEnvironment
import org.jetbrains.gradle.ext.ActionDelegationConfig.TestRunner

import java.nio.file.Files

buildscript {
    repositories() {
        mavenLocal()
        mavenCentral()
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.7.0'
    }
}

plugins {
    id "org.jetbrains.gradle.plugin.idea-ext" version "1.0.1"
}

group 'net.covers1624.WorkspaceTool'
version '0.5.0'

version = "$version." + (System.getenv("BUILD_NUMBER") ?: "1")
println "Starting build of WorkspaceTool, Version: ${version}"

allprojects {
    // TODO There is a bug somewhere in Gradle, putting this inside `dependencyResolutionManagement` in settings.gradle
    //  causes artifacts on my maven to be un-resolvable..
    repositories {
        mavenLocal()
        mavenCentral()
        maven { url 'https://maven.covers1624.net/' }
        maven { url 'https://files.minecraftforge.net/maven/' }
        maven { url 'https://repo.gradle.org/gradle/libs-releases/' }
    }
}

subprojects { subProject ->
    // Test api is special, hardcode no Gradle artifacts, and add to testRuntimeOnly for all other projects.
    boolean isTestApi = subProject.name == 'test-api'
    apply plugin: 'java'
    apply plugin: 'java-library'
    if (!isTestApi) {
        apply plugin: 'maven-publish'
        apply plugin: 'signing'
    }

    group rootProject.group
    version rootProject.version

    configurations {
        testCompileOnly.extendsFrom compileOnly
    }

    dependencies {
        compileOnly 'com.google.code.findbugs:jsr305:3.0.2'
        compileOnly 'org.jetbrains:annotations:24.0.1'

        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.14.0'
        testImplementation 'org.junit.jupiter:junit-jupiter-params:5.14.0'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.14.0'
        testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.14.0'
        if (!isTestApi) {
            testImplementation project(':test-api')
        }
        testImplementation 'org.assertj:assertj-core:3.27.6'
    }

    test {
        useJUnitPlatform()

        systemProperty('GradleModelExtractor.isGradleTesting', 'true')
    }

    if (isTestApi) return
    publishing {
        repositories {
            if (System.getenv('MAVEN_PASS')) {
                maven {
                    url "https://nexus.covers1624.net/repository/maven-releases/"
                    credentials {
                        username 'covers1624'
                        password System.getenv('MAVEN_PASS')
                    }
                }
            }
        }

        publications {
            publication(MavenPublication) {
                pom {
                    name = 'WorkspaceTool'
                    description = 'WorkspaceTool, A Minecraft Modding workspace tool.'
                    url = 'https://github.com/covers1624/WorkspaceTool'

                    scm {
                        url = 'https://github.com/covers1624/WorkspaceTool'
                        connection = 'scm:git:git://github.com/covers1624/WorkspaceTool.git'
                        connection = 'scm:git:git@github.com:covers1624/WorkspaceTool.git'
                    }

                    issueManagement {
                        system = 'github'
                        url = 'https://github.com/covers1624/WorkspaceTool/issues'
                    }
                    licenses {
                        license {
                            name = "MIT"
                            url = 'https://raw.githubusercontent.com/covers1624/WorkspaceTool/master/LICENSE.txt'
                            distribution = 'repo'
                        }
                    }
                    developers {
                        developer {
                            id = 'covers1624'
                            name = 'covers1624'
                        }
                    }
                }
            }
        }
    }

    signing {
        if (System.getenv('GPG_PRIVATE_KEY')) {
            useInMemoryPgpKeys(
                    new File(System.getenv('GPG_PRIVATE_KEY')).text,
                    System.getenv('GPG_PRIVATE_KEY_PASS')
            )
        } else if (System.getenv("GPG_PRIVATE_KEY_FILE")) {
            useInMemoryPgpKeys(
                    new String(System.getenv('GPG_PRIVATE_KEY_FILE').decodeBase64(), java.nio.charset.StandardCharsets.UTF_8),
                    System.getenv('GPG_PRIVATE_KEY_PASS')
            )
        } else if (project.hasProperty('gpgPrivateKey')) {
            useInMemoryPgpKeys(
                    new File(project.getProperty('gpgPrivateKey')).text,
                    project.getProperty('gpgPrivateKeyPass')
            )
        } else {
            return
        }
        sign publishing.publications.publication
    }
}

configurations {
    packing {
        attributes {
            attribute(TargetJvmEnvironment.TARGET_JVM_ENVIRONMENT_ATTRIBUTE, objects.named(TargetJvmEnvironment, TargetJvmEnvironment.STANDARD_JVM))
        }
    }
    gradlePluginPath {
        attributes {
            attribute(TargetJvmEnvironment.TARGET_JVM_ENVIRONMENT_ATTRIBUTE, objects.named(TargetJvmEnvironment, TargetJvmEnvironment.STANDARD_JVM))
        }
    }
}

dependencies {
    packing project(':core')
    gradlePluginPath project(':gradle-extract')
    gradlePluginPath project(':mcforge-gradle-extract')
    gradlePluginPath project(':neoforge-gradle-extract')
}

tasks.register('genVersionManifest') {
    ext {
        output = file("build/libs/manifest-${version}.json")
    }
    inputs.files(configurations.packing)
    inputs.files(configurations.gradlePluginPath)
    outputs.file output

    doLast {
        def mainClasspath = []
        def gradleClasspath = []
        long totalSize
        configurations.packing.resolvedConfiguration.resolvedArtifacts.each {
            def len = it.file.length()
            totalSize += len
            mainClasspath.add([
                    "artifact": toCoords(it),
                    "sha256"  : Files.readAllBytes(it.file.toPath()).sha256(),
                    "size"    : len
            ])
        }
        configurations.gradlePluginPath.resolvedConfiguration.resolvedArtifacts.each {
            def len = it.file.length()
            totalSize += len
            gradleClasspath.add([
                    "artifact": toCoords(it),
                    "sha256"  : Files.readAllBytes(it.file.toPath()).sha256(),
                    "size"    : len
            ])
        }
        def manifest = [
                'wrapperVersionFilter': '[0.5.0,)',
                'javaVersion'      : 'JAVA_21',
                'classPaths'       : [
                        'main'  : mainClasspath,
                        'gradle': gradleClasspath
                ],
                'javaArgs'         : [
                        '-cp',
                        '${classPaths.main}',
                        '-Dnet.covers1624.wstool.gradle_classpath=${classPaths.gradle}',
                        'net.covers1624.wstool.WorkspaceTool'
                ]
        ]
        def json = JsonOutput.prettyPrint(JsonOutput.toJson(manifest))
        Files.write(output.toPath(), json.getBytes("UTF-8"))
//        logger.lifecycle("Total Size: ${(int) (totalSize / 1024)}kb")
    }
}

tasks.register('genGradlePluginMetaDev') {
    ext {
        output = project(':gradle').file("src/main/generated/gradle_plugin_data.json")
    }
    inputs.files(configurations.gradlePluginPath)
    outputs.file output

    def dependencies = []
    configurations.gradlePluginPath.resolvedConfiguration.resolvedArtifacts.each {
        if (it.id.componentIdentifier instanceof ProjectComponentIdentifier) {
            dependencies << project(it.id.componentIdentifier.projectPath).projectDir.absolutePath
        } else {
            dependencies << it.file.absolutePath
        }
    }
    def json = JsonOutput.prettyPrint(JsonOutput.toJson(dependencies))
    Files.createDirectories(output.toPath().getParent())
    Files.write(output.toPath(), json.getBytes("UTF-8"))
}

task clean {
    doLast {
        delete(tasks.genVersionManifest.output)
    }
}

idea.project.settings {
    delegateActions {
        delegateBuildRunToGradle = false
        testRunner = TestRunner.PLATFORM
    }
    taskTriggers {
        beforeSync 'genGradlePluginMetaDev'
    }
}

def toCoords(ResolvedArtifact artifact) {
    def id = artifact.moduleVersion.id
    def classifier = artifact.classifier ? ":" + artifact.classifier : ""
    return "${id.group}:${artifact.name}:${id.version}${classifier}"
}
